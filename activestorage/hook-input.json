{"session_id":"fdcba714-acab-4ca0-b528-aafcab4b8b66","transcript_path":"/Users/richard/.claude/projects/-Users-richard-git-rails-activestorage/fdcba714-acab-4ca0-b528-aafcab4b8b66.jsonl","cwd":"/Users/richard/git/rails/activestorage","hook_event_name":"PostToolUse","tool_name":"Edit","tool_input":{"file_path":"/Users/richard/git/rails/activestorage/app/javascript/activestorage/multipart_blob_upload.js","old_string":"  updatePartProgress(partIndex, progress) {\n    console.debug(\"update part progress\")\n    this.partProgress[partIndex] = progress\n    clearTimeout(this.debounceTimeoutId)\n    this.debounceTimeoutId = setTimeout(\n      () => this.emitProgressEvent(), this.progressDebounceMs\n    )\n  }","new_string":"  updatePartProgress(partIndex, progress) {\n    console.debug(\"update part progress\")\n    this.partProgress[partIndex] = progress\n    \n    const now = Date.now()\n    if (now - this.lastProgressEmitTime >= this.progressThrottleMs) {\n      this.emitProgressEvent()\n      this.lastProgressEmitTime = now\n    }\n  }"},"tool_response":{"filePath":"/Users/richard/git/rails/activestorage/app/javascript/activestorage/multipart_blob_upload.js","oldString":"  updatePartProgress(partIndex, progress) {\n    console.debug(\"update part progress\")\n    this.partProgress[partIndex] = progress\n    clearTimeout(this.debounceTimeoutId)\n    this.debounceTimeoutId = setTimeout(\n      () => this.emitProgressEvent(), this.progressDebounceMs\n    )\n  }","newString":"  updatePartProgress(partIndex, progress) {\n    console.debug(\"update part progress\")\n    this.partProgress[partIndex] = progress\n    \n    const now = Date.now()\n    if (now - this.lastProgressEmitTime >= this.progressThrottleMs) {\n      this.emitProgressEvent()\n      this.lastProgressEmitTime = now\n    }\n  }","originalFile":"export class MultipartBlobUpload {\n  constructor(blobRecord) {\n    this.file = blobRecord.file\n    this.blobId = blobRecord.attributes.id\n\n    const { upload_id, part_size, part_urls } = blobRecord.directUploadData\n\n    this.uploadId = upload_id\n    this.partSize = part_size\n    this.partUrls = part_urls\n    this.uploadedParts = []\n    this.maxConcurrentUploads = 4\n    this.progressThrottleMs = 100\n    this.retryableRequest = new RetryableRequest()\n\n    this.partProgress = new Array(part_urls.length).fill(0)\n    this.lastProgressEmitTime = 0\n\n    this.xhr = new XMLHttpRequest()\n\n    this.debugProgressEventCount = 0\n  }\n\n  create(callback) {\n    this.callback = callback\n    this.uploadPartsConcurrently()\n  }\n\n  uploadPartsConcurrently() {\n    this.uploadPartsWithConcurrencyLimit(this.partUrls, this.maxConcurrentUploads)\n      .then(() => {\n        console.debug(\"All parts uploaded, completing multipart upload\")\n        this.completeMultipartUpload()\n      })\n      .catch(error => { this.callback(error) })\n  }\n\n  uploadPartsWithConcurrencyLimit(parts, limit) {\n    return new Promise((resolve, reject) => {\n      const results = []\n      const executing = []\n      let partIndex = 0\n\n      const startNextUpload = () => {\n        if (partIndex >= parts.length) {\n          if (executing.length === 0) {\n            resolve()\n          }\n          return\n        }\n\n        const partData = parts[partIndex++]\n        const uploadPromise = this.uploadPartAsync(partData)\n\n        results.push(uploadPromise)\n        executing.push(uploadPromise)\n\n        uploadPromise\n          .then(() => {\n            executing.splice(executing.indexOf(uploadPromise), 1)\n            startNextUpload()\n          })\n          .catch(error => {\n            executing.splice(executing.indexOf(uploadPromise), 1)\n            reject(error)\n          })\n      }\n\n      for (let i = 0; i < Math.min(limit, parts.length); i++) {\n        startNextUpload()\n      }\n    })\n  }\n\n  uploadPartAsync(partData) {\n    return new Promise((resolve, reject) => {\n      const start = (partData.part_number - 1) * this.partSize\n      const end = Math.min(start + this.partSize, this.file.size)\n      const chunk = this.file.slice(start, end)\n\n      console.debug(`Part ${partData.part_number}/${this.partUrls.length} starting`)\n\n      this.uploadPart(partData.url, chunk, (error, etag) => {\n        if (error) {\n          reject(error)\n        } else {\n          this.uploadedParts.push({ etag: etag, part_number: partData.part_number })\n          console.debug(`Part ${partData.part_number}/${this.partUrls.length} uploaded`)\n          resolve(etag)\n        }\n      }, partData.part_number)\n    })\n  }\n\n  uploadPart(url, chunk, callback, partNumber) {\n    this.retryableRequest.execute((onSuccess, onError) => {\n      const xhr = new XMLHttpRequest()\n      xhr.open(\"PUT\", url, true)\n      xhr.responseType = \"text\"\n\n      xhr.upload.addEventListener(\"progress\", (event) => {\n        if (event.lengthComputable) {\n          const partProgress = event.loaded\n          this.updatePartProgress(partNumber - 1, partProgress)\n        }\n      })\n\n      xhr.addEventListener(\"load\", () => {\n        if (xhr.status >= 200 && xhr.status < 300) {\n          this.updatePartProgress(partNumber - 1, chunk.size)\n          onSuccess(xhr.getResponseHeader(\"ETag\"))\n        } else {\n          onError({\n            status: xhr.status,\n            message: `Failed to upload part: ${xhr.status}`,\n            context: \"Part upload\"\n          })\n        }\n      })\n\n      xhr.addEventListener(\"error\", () => {\n        onError({\n          networkError: true,\n          message: \"Network error\",\n          context: \"Part upload\"\n        })\n      })\n\n      xhr.send(chunk)\n    })\n      .then(etag => callback(null, etag))\n      .catch(error => callback(new Error(error.message)))\n  }\n\n  updatePartProgress(partIndex, progress) {\n    console.debug(\"update part progress\")\n    this.partProgress[partIndex] = progress\n    clearTimeout(this.debounceTimeoutId)\n    this.debounceTimeoutId = setTimeout(\n      () => this.emitProgressEvent(), this.progressDebounceMs\n    )\n  }\n\n  emitProgressEvent() {\n    console.debug(\"! emit part progress\")\n    const totalBytesUploaded = this.partProgress.reduce((sum, p) => sum + p, 0)\n    const progressEvent = new ProgressEvent(\"progress\", {\n      lengthComputable: true,\n      loaded: totalBytesUploaded,\n      total: this.file.size\n    })\n    this.debugProgressEventCount++\n    this.xhr.upload.dispatchEvent(progressEvent)\n  }\n\n  completeMultipartUpload() {\n    // Sort parts by part_number to ensure correct order\n    this.uploadedParts.sort((a, b) => a.part_number - b.part_number)\n\n    this.retryableRequest.execute((onSuccess, onError) => {\n      const xhr = new XMLHttpRequest()\n      const completeUrl = `/rails/active_storage/direct_uploads/${this.blobId}`\n\n      // Debug\n      console.debug(\"TOTAL PROGRESS EVENTS:\", this.debugProgressEventCount)\n\n      xhr.open(\"PUT\", completeUrl, true)\n      xhr.setRequestHeader(\"Content-Type\", \"application/json\")\n      xhr.setRequestHeader(\"X-CSRF-Token\", this.getCSRFToken())\n\n      xhr.addEventListener(\"load\", () => {\n        if (xhr.status >= 200 && xhr.status < 300) {\n          onSuccess(this.file)\n        } else {\n          onError({\n            status: xhr.status,\n            message: \"Failed to complete multipart upload\",\n            context: \"Complete multipart upload\"\n          })\n        }\n      })\n\n      xhr.addEventListener(\"error\", () => {\n        onError({\n          networkError: true,\n          message: \"Network error completing multipart upload\",\n          context: \"Complete multipart upload\"\n        })\n      })\n\n      xhr.send(JSON.stringify({\n        blob: {\n          upload_id: this.uploadId,\n          parts: this.uploadedParts\n        }\n      }))\n    })\n      .then(file => this.callback(null, file))\n      .catch(error => this.callback(new Error(error.message)))\n  }\n\n  // TODO: See if we can reuse something else that also needs the CSRF token\n  getCSRFToken() {\n    const meta = document.querySelector(\"meta[name=\\\"csrf-token\\\"]\")\n    return meta ? meta.content : \"\"\n  }\n}\n\nclass RetryableRequest {\n  constructor(options = {}) {\n    this.maxRetries = options.maxRetries || 5\n    this.baseDelay = options.baseDelay || 2000\n    this.isRetryableStatus = options.isRetryableStatus || ((status) => status >= 500 || status === 408 || status === 429)\n  }\n\n  execute(requestFn, attempt = 0) {\n    return new Promise((resolve, reject) => {\n      const onSuccess = (result) => resolve(result)\n      const onError = (error) => {\n        if (attempt < this.maxRetries && this.shouldRetry(error)) {\n          const delay = Math.round(this.baseDelay * Math.pow(2, attempt) + Math.random() * 1000)\n          console.debug(`${error.context || \"Request\"} failed, retrying in ${delay}ms (attempt ${attempt + 1}/${this.maxRetries}): ${error.message}`)\n          setTimeout(() => {\n            this.execute(requestFn, attempt + 1).then(resolve, reject)\n          }, delay)\n        } else {\n          reject(error)\n        }\n      }\n\n      requestFn(onSuccess, onError)\n    })\n  }\n\n  shouldRetry(error) {\n    return error.networkError || (error.status && this.isRetryableStatus(error.status))\n  }\n}\n\n","structuredPatch":[{"oldStart":135,"oldLines":10,"newStart":135,"newLines":12,"lines":["   updatePartProgress(partIndex, progress) {","     console.debug(\"update part progress\")","     this.partProgress[partIndex] = progress","-    clearTimeout(this.debounceTimeoutId)","-    this.debounceTimeoutId = setTimeout(","-      () => this.emitProgressEvent(), this.progressDebounceMs","-    )","+    ","+    const now = Date.now()","+    if (now - this.lastProgressEmitTime >= this.progressThrottleMs) {","+      this.emitProgressEvent()","+      this.lastProgressEmitTime = now","+    }","   }"," ","   emitProgressEvent() {"]}],"userModified":false,"replaceAll":false}}